+!     n/u a-addr --           add cell to memory
>      n1 n2 -- flag           test n1>n2, signed
CONSTANT   n --           define a Forth constant
EXECUTE   i*x xt -- j*x   execute Forth word 'xt'
EXIT   --                 exit a colon definition
FILL   c-addr u c --        fill memory with char
I      -- n   R: sys1 sys2 -- sys1 sys2
                     get the innermost loop index
J      -- n   R: 4*sys -- 4*sys
                        get the second loop index
UM*    u1 u2 -- ud       unsigned 16x16->32 mult.
UM/MOD ud u1 -- u2 u3     unsigned 32/16->16 div.
UNLOOP --   R: sys1 sys2 --       drop loop parms
VARIABLE   --             define a Forth variable

               ANS Forth Extensions
These are optional words whose definitions are
specified by the ANS Forth document.

<>     x1 x2 -- flag               test not equal 
BYE    i*x --                      return to CP/M
CMOVE  c-addr1 c-addr2 u --      move from bottom
CMOVE> c-addr1 c-addr2 u --         move from top
KEY?   -- flag        return true if char waiting
M+     d1 n -- d2            add single to double
NIP    x1 x2 -- x2              per stack diagram
TUCK   x1 x2 -- x2 x1 x2        per stack diagram
U>     u1 u2 -- flag         test u1>u2, unsigned 

               Private Extensions
These are words which are unique to CamelForth.
Many of these are necessary to implement ANS
Forth words, but are not specified by the ANS
document.  Others are functions I find useful.

(do)   n1|u1 n2|u2 --  R: -- sys1 sys2
                             run-time code for DO
(loop) R: sys1 sys2 --  | sys1 sys2
                           run-time code for LOOP
(+loop)  n --   R: sys1 sys2 --  | sys1 sys2
                          run-time code for +LOOP
><     x1 -- x2                        swap bytes 
?branch  x --                  branch if TOS zero
BDOS   DE C -- A                   call CP/M BDOS
branch --                           branch always
PC!    c p-addr --            output char to port
PC@    p-addr -- c           input char from port
SCAN   c-addr1 u1 c -- c-addr2 u2
                               find matching char
SKIP   c-addr1 u1 c -- c-addr2 u2
                              skip matching chars
S=     c-addr1 c-addr2 u -- n      string compare
               n<0: s1<s2, n=0: s1=s2, n>0: s1>s2
USER   n --              define user variable 'n'
